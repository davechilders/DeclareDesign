% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/declare_potential_outcomes.R
\name{declare_potential_outcomes}
\alias{declare_potential_outcomes}
\title{Declare potential outcomes.}
\usage{

  declare_potential_outcomes(potential_outcomes_function = default_potential_outcomes_function,
  formula = NULL, outcome_variable_name = NULL, condition_names = NULL,
  inherit_condition_names = FALSE, sep = "_",
  assignment_variable_name = "Z", interference = NULL, attrition = NULL,
  description = NULL, ...)
}
\arguments{
\item{potential_outcomes_function}{A function that takes a data frame as the argument \code{data} and returns a vector of length \code{nrow(data)}. Use to define potential outcomes as a function of treatment assignment(s) and pre-treatment covariates See details.}

\item{formula}{An object of class \link{formula} (or one that can be coerced to that class): a symbolic description of the relationship between potential outcomes, treatment assignment(s) and pre-treatment characateristics. See details.}

\item{outcome_variable_name}{The name of the outcome variable as a character string. Can be omitted if a formula is provided.}

\item{condition_names}{A vector of treatment condition names, such as c(0, 1). If there are multiple treatments, a list of vectors of condition names with one vector for each treatment. Required for the first \code{potential_outcomes} object supplied to a design. Can be omitted for subsequent \code{potential_outcomes} objects if \code{inherit_condition_names = TRUE} is specified.}

\item{inherit_condition_names}{A logical indicating whether \code{condition_names} should be inherited from a previous \code{potential_outcomes} object (TRUE) or not (FALSE).}

\item{sep}{A character string indicating the separator that will be used to construct the variable names of potential outcomes. Defaults to \code{_} which yields variable names such as \code{Y_Z_1} and \code{Y_Z_0}.}

\item{assignment_variable_name}{A character string that contains the variable name of the treatment assignment indicator that appears in the potential outcomes \code{formula} or the \code{potential_outcomes_function}. Defaults to \code{"Z"}. If there are multiple treatments, a vector of treatment indicator names with one element per treatment is required.}

\item{interference}{An interference object created by \code{\link{declare_interference}}.}

\item{attrition}{An attrition object created by \code{\link{declare_attrition}}.}

\item{description}{A character string containing a description of the potential outcomes.}

\item{...}{Other arguments passed to the \code{potential_outcomes_function}.}
}
\value{
potential_outcomes object.
}
\description{
Potential outcomes are endogenous outcomes of interest that are not under the direct control of the researcher. Examples include whether a drug is offered by a doctor, whether a drug is ingested, whether a patient survives, and whether outcomes are measured. Use this function to define a mapping between manipulands (typically randomly assigned treatments), ancestor variables (typically pre-treatment covariates) and potential outcomes. For instance, you may declare patient survival to be a function of whether or not the patient receives an experimental drug (a randomly assigned treatment) and the patient's pre-treatment health condition (a pre-treatment covariate). This gives rise to two potential outcomes for each patient - whether the patient survives when he receives the drug (treated potential outcome) and whether the patient dies when he does not receive the drug (control potential outcome).
}
\details{
Use the \code{formula} argument to specify the relationship between potential outcomes, treatment assignments and pre-treatment covariates. A typical formula has the form \code{Y ~ terms}. \code{Y} is the name of the outcome variable. \code{terms} is an expression that typically consists of functions of the treatment assignment indicator(s)  and of the pre-treatment covariates that have been built into the \code{population} object. If a \code{formula} is supplied, there is no need to supply a \code{potential_outcomes_function}.

         An alternative way to specify the relationship between potential outcomes, treatment assignments and pre-treatment covariates is to use the \code{potential_outcomes_function} argument. The function supplied to this argument needs to return an outcome vector of length \code{nrow(data)} when applied to a data frame that contains the following columns: 
         \itemize{
           \item  one column for each treatment indicator named according to the character string(s) that have been supplied to the \code{assignment_variable_name} argument,
           \item  the ID variables and pre-treatment covariates that have been built into the \code{population} object using the \link{declare_population} function.
         }
         
         
         There is no need to supply a \code{formula} if a \code{potential_outcomes_function} is supplied.
         
         The \code{potential_outcomes_function} argument defaults to the \link{default_potential_outcomes_function} which takes the arguments \code{formula} and \code{data} and returns the corresponding outcome vector.
         
         If more than one potential outcomes object is created, subsequent potential outcomes can be functions of previously specified potential outcomes (see examples).    
       
         See the \link{proportion_potential_outcomes_function} for a built-in potential outcomes function that can be used to create proportional potential outcomes.
}
\examples{
## Declare potential outcomes using potential_outcomes_function

 population <- declare_population(noise = "rnorm(n_)", size = 250)
 
 my_potential_outcomes <- function(data) { with(data, Z * 0.25 + noise) }
 
 potential_outcomes <- declare_potential_outcomes(potential_outcomes_function = my_potential_outcomes,
                                                   outcome_variable_name = 'Y',
                                                   condition_names = c(0, 1))
 
 pop_draw <- draw_population(population = population, potential_outcomes = potential_outcomes)
 
 head(pop_draw)
 
 ## Declare potential outcomes using formula
 
 population <- declare_population(noise = "rnorm(n_)", size = 250)
 
 potential_outcomes <- declare_potential_outcomes(formula = Y ~ 0.25 * Z + noise,
                                                   condition_names = c(0, 1),
                                                   assignment_variable_name = "Z")
                                                   
 pop_draw <- draw_population(population = population, potential_outcomes = potential_outcomes)
 
 head(pop_draw)
 
 ## Multiple treatments
 
 population <- declare_population(noise = "rnorm(n_)", size = 250)
 
 potential_outcomes <- declare_potential_outcomes(formula = Y ~ 5 + 1*Z1 + 2*Z2 - 3*Z1*Z2 + noise,
                                                   condition_names = list(Z1 = c(0, 1), 
                                                   Z2 = c(0, 1)),
                                                   assignment_variable_name = c("Z1", "Z2"))
                                                   
  pop_draw <- draw_population(population = population, potential_outcomes = potential_outcomes)
  
  head(pop_draw)
  
 ## Multiple potential outcomes 
 
 population <- declare_population(noise = "rnorm(n_)", size = 250)
 
 potential_outcomes_1 <- declare_potential_outcomes(formula = Y ~ 5 + .5*Z*rnorm(n_) + noise,
                                                     condition_names = c(0, 1),
                                                     assignment_variable_name = "Z")
 
 potential_outcomes_2 <- declare_potential_outcomes(formula = Y2 ~ 5 + .25*Z + noise,
                                                     inherit_condition_names = TRUE,
                                                     assignment_variable_name = "Z")
 
 pop_draw <- draw_population(population = population, potential_outcomes = list(potential_outcomes_1, potential_outcomes_2))
 
 head(pop_draw)
 
 ## Potential outcomes as a function of previously specified potential outcomes
 
 population <- declare_population(noise = "rnorm(n_)", size = 250)
 
 potential_outcomes_1 <- declare_potential_outcomes(formula = D ~ (Z == 1) * (noise > 0),
                                                     condition_names = c(0, 1),
                                                     assignment_variable_name = "Z")

 potential_outcomes_2 <- declare_potential_outcomes(formula = Y ~ 5 + .5*D*rnorm(n_) + noise,
                                                     condition_names = c(0, 1),
                                                     assignment_variable_name = "D")
                                                     
 pop_draw <- draw_population(population = population, potential_outcomes = list(potential_outcomes_1, potential_outcomes_2))
 
 head(pop_draw)
 
 
}

