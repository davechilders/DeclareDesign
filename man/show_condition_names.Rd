% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/factorial_template.R
\name{show_condition_names}
\alias{show_condition_names}
\title{2x2 Factorial Template}
\usage{
show_condition_names(factors = c(2, 2))
}
\arguments{
\item{N}{A scalar (must be an integer) indicating the total population size.}

\item{n}{A scalar (must be an integer) indicating the total sample size. By default, n = N.}

\item{m}{A scalar (must be an integer) indicating the number of arms. Note that m > 1 for any experiment.}

\item{probability_each}{A vector of four elements indicating the probability of assignment to eaach treatment condition in the order Z00, Z01, Z10, Z11. The elements in the vector must sum to 1. By default, units have a 1/4 probability of assignment to each experimental group.}

\item{cond_means}{A vector with four elements indicating the mean of the realized potential outcome in each treatment condition in the order Z00, Z01, Z10, Z11.}

\item{noise_scale}{A scalar or a vector of four elements indicating the standard deviation of individual-level noise for each experimental group. If it is a scalar, the standard deviation of individual-level noise is constant across all treatment groups. If it is a vector, the standard deviation of noise is group-specific. The elements in the vector correspond to treatment condition in the order Z00, Z01, Z10, Z11.}

\item{binary_POs}{A logical argument indicating whether potential outcomes are binary. If binary_POs = TRUE, all elements in the vector cond_means must be valid probabilities (between 0 and 1, inclusive). By default, binary_POs = FALSE.}

\item{coef_X}{A scalar coefficient on a covariate, X, in the potential outcomes function.  By default, coef_X = 0.}

\item{location_scale_X}{A vector of length two indicating the mean and standard deviation of covariate X. By default, location_scale_X = c(0, 1).}

\item{cov_adjustment}{A logical argument indicating whether covariate adjustment should be used in estimation. By default, cov_adjustment = F.}

\item{block_var_vector}{For non-clustered designs, an optional vector of length N indicating the block to which each unit belongs.}

\item{block_var_probs}{For non-clustered designs, a vector specifying the distribution of a multinomial blocking variable (probability per level). The elements in the vector must be between 0 and 1 and sum to 1.}

\item{blocked_RA}{A logical argument indicating whether blocked random assignment should be used. By default, blocked_RA = F.}

\item{block_prob_each}{A matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the probabilites of assignment to treatment within each block. The rows should respect the ordering of the blocks as determined by sort(unique(block_var)). Use only if the probabilities of assignment should vary by block, otherwise use prob_each. Each row of block_prob_each must sum to 1.}

\item{n_clust_pop}{A scalar (must be an integer) indicating the number of equal-sized clusters in the population.}

\item{n_clust_samp}{A scalar (must be an integer) indicating the number of equal-sized clusters in the sample.}

\item{n_blocks}{For clustered designs, users can specify the number of equal-sized blocks in the population.}

\item{SE}{Indicates the standard error estimator. Options include "OLS" for classical OLS standard errors, "robust" for Huber-White heteroskedasticity-robust standard errors, or "clustered" for robust clustered standard errors. By default, the "robust" standard errors are used for non-clustered designs and "clustered" standard errors are used for clustered designs.}

\item{custom_pop_list}{Allows users to input cluster-assigned designs with clusters and blocks of varying sizes. Users should input a list of three vectors: (1) individuals using rep(1, N), where N is the population size; (2), clusters, a vector containing the number per cluster such that the sum of the vector is N; and (3) blocks, a vector containing the number of clusters in each block such that the sum of the vector is equal to the length of the cluster vector. All elements must be positive integers.}
}
\value{
A design
}
\description{
2x2 Factorial Template
}
\examples{
\dontrun{
design <- factorial_template(N = 5000, n = 500, cond_means = c(1, 1.5, 1.3, 1.8), noise_scale = 1)
design2 <- factorial_template(N = 5000, n_clust_pop = 100, n_blocks = 10, 
                             cond_means = c(1, 1.5, 1.3, 1.8), noise_scale = 1)
}                            
}

