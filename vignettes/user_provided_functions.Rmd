---
title: "How to Design and Pre-Register Experimental Designs with Baseline Data"
author: "Experiments in Governance and Politics (EGAP)"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to Pre-Register a Simple Experimental Design using the registration package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
This vignette demonstrates how to design and pre-register an experiment after baseline data has been collected.

```{r, echo = FALSE}
library(experimentr)
library(xtable)
set.seed(20)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, error = TRUE, message = FALSE, 
                      eval = TRUE, tidy = TRUE, tidy.opts = list(width.cutoff = 50),
                      strip_white = TRUE, results = 'asis', fix.ext = 'pdf')
```

# A simple experiment

## Designing the experiment

First, we define the sample frame from which we will draw a sample to run the experiment from. This includes defining the levels of analysis and the covariates at each level. The below example shows how to construct a variable with a user-defined function, here sampling income levels from 1 to 25 with replacement.

```{r}
sample <- declare_sample(
  income = function() sample(1:25, 500, replace = T),
  noise = declare_variable(),
  N = 500)
```

Second, we define the potential outcomes, which will be simulated based on the baseline covariate data. Here we illustrate a custom function that determines potential outcomes -- a binomial distribution with a probit link. You can type any function, including one you make up, in place of rbinom. (Or none at all for OLS.)

```{r}
potential_outcomes     <-  declare_potential_outcomes(
  condition_names = c("Z0","Z1"),
  outcome_formula = Y ~ rbinom(500, size = 1, prob = pnorm(.01 + 0*Z0 + .2*Z1 + .1*income + rnorm(500)))
)
```

Fourth, we define one or more analyses we will run based on simulated data. This analysis will also be used for power analysis. Here we define a custom estimator (probit regression) and a custom QOI function (for this example, it just pulls the probit coefficient, which is note an estimate of any causal quantity).


```{r}
probit_regression <- function(formula, subset = NULL, weights = NULL, data, ...){
  args_list <- c(list(formula = formula, subset = subset, weights = weights, data = data), list(...))
  args_list$family <- binomial(link = "probit")
  do.call(glm, args = args_list)
}

probit_qoi_temp <- function(fit, statistics = c("est", "se", "p", "ci_lower", "ci_upper")){
  coef <- summary(fit)$coefficients[2, 1]
  se <- summary(fit)$coefficients[2, 2]
  p <- summary(fit)$coefficients[2, 4]
  ci_upper <- coef + 1.96*se
  ci_lower <- coef - 1.96*se
  stats <- matrix(c(coef, se, p, ci_lower, ci_upper), dimnames = list(c("est", "se", "p", "ci_lower", "ci_upper"), "Y~Zlm"))
  return(stats)
}

analysis      <- declare_analysis(formula = Y ~ Z, treatment_variable = "Z", 
                                  estimator = probit_regression, quantity_of_interest = probit_qoi_temp)
```

Then we declare the design of the experiment, in this case a simple one without clusters or blocking. Here we demonstrate how to use a custom random assignment function, in this case simple random sampling of "Z0" and "Z1".

```{r}
assign_function <- function()
    return(sample(c("Z0", "Z1"), 500, replace = T))
  
design <- declare_design(potential_outcomes = potential_outcomes, custom_assignment_function = assign_function)
```

Before finalizing the design, we conduct a power analysis to determine whether 500 units and 10 clusters (villages) are sufficient. To do this, we use the diagnose function.

```{r}
simulations <- diagnose(potential_outcomes = potential_outcomes, 
                                   sample = sample, 
                                   design = design, 
                                   analysis = analysis)
kable(summary(simulations), digits = 3)
```

## Mock analysis

After settling on a sample size and a final design, we can conduct a mock analysis of the data to ensure we are satisfied with the analysis of the data. To do this, we create mock data -- simulated from the distributions we set -- and then run the analyses on the simulated data.

```{r}
mock <- make_data(sample = sample, potential_outcomes = potential_outcomes, design = design,
                  assign_treatment = TRUE, observed_outcomes = TRUE, treatment_variable = "Z")
```

```{r}
kable(get_estimates(analysis = analysis, data = mock))
```
